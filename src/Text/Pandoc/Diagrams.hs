
module Text.Pandoc.Diagrams where

import           Control.Monad                   (when)
import           Data.List                       (delete)
import           Diagrams.Backend.Cairo
import           Diagrams.Backend.Cairo.Internal
import qualified Diagrams.Builder                as DB
import           Diagrams.Prelude                (centerXY, pad, (&), (.~))
import           Diagrams.Size                   (dims)
import           Linear                          (V2 (..), zero)
import           System.Directory                (createDirectory,
                                                  doesDirectoryExist)
import           System.FilePath                 ((<.>), (</>), pathSeparator)
import           System.IO
import           Text.Pandoc.Builder             hiding (code, codeBlock)
import           Text.Pandoc.Generic

-- TODO choose output format based on pandoc target
backendExt :: String
backendExt = "png"

data Opts = Opts {
    _outDir     :: FilePath,
    _expression :: String
    }

data Echo = Above | Below
     deriving (Read, Show)

-- | Transform a blog post by looking for code blocks with class
--   @diagrams@, and replacing them with images generated by evaluating the
--   identifier @diagrams@ and rendering the resulting diagram.  In
--   addition, blocks with class @diagrams-def@ are collected (and deleted
--   from the output) and provided as additional definitions that will
--   be in scope during evaluation of all @diagrams@ blocks.
renderBlockDiagrams :: FilePath -> Bool -> Pandoc -> IO Pandoc
renderBlockDiagrams outDir absolutePath p = bottomUpM (insertDiagrams (Opts outDir "example") absolutePath) p

insertDiagrams :: Opts -> Bool -> Block -> IO Block
insertDiagrams opts absolutePath (CodeBlock (ident, classes, attrs) code) | "diagrams" `elem` classes = do
        d <- compileDiagram opts code
        let imgBlock = case d of
             Left _err     -> error "diagram not compiling"
             Right imgName -> Plain [Image [] ((if absolutePath then pathSeparator : imgName else imgName),"")]
        let codeBlock = CodeBlock (ident, "haskell":delete "diagrams" classes, attrs) code
        let block' = case readEcho attrs of
             (Just Above) -> Table [] [AlignLeft] [] [] [[[codeBlock]], [[imgBlock]]]
             (Just Below) -> Table [] [AlignLeft] [] [] [[[imgBlock]], [[codeBlock]]]
             Nothing -> imgBlock
        return block'
insertDiagrams _ _ block = return block

readEcho :: [(String, String)] -> Maybe Echo
readEcho attrs = case lookup "echo" attrs of
   Just e  -> Just (read e)
   Nothing -> Nothing

-- Copied from https://github.com/diagrams/diagrams-doc/blob/master/doc/Xml2Html.hs
-- With the CPP removed, thereby requiring Cairo
-- TODO clean this up, move it into -builder somehow
-- | Compile the literate source code of a diagram to a .png file with
--   a file name given by a hash of the source code contents
compileDiagram :: Opts -> String -> IO (Either String String)
compileDiagram opts src = do
  ensureDir $ _outDir opts

  let
      bopts :: DB.BuildOpts Cairo V2 Double
      bopts = DB.mkBuildOpts

                Cairo

                zero

                (CairoOptions "default.png" (dims $ V2 500 200) PNG False)

                & DB.snippets .~ [src]
                & DB.imports  .~
                  [ "Diagrams.TwoD.Types"      -- WHY IS THIS NECESSARY =(
                  , "Diagrams.Core.Points"
                      -- GHC 7.2 bug?  need  V (Point R2) = R2  (see #65)
                  , "Diagrams.Backend.Cairo"
                  , "Diagrams.Backend.Cairo.Internal"
                  , "Graphics.SVGFonts"
                  , "Data.Typeable"
                  ]
                & DB.pragmas .~ ["DeriveDataTypeable"]
                & DB.diaExpr .~ _expression opts
                & DB.postProcess .~ (pad 1.1 . centerXY)
                & DB.decideRegen .~
                  (DB.hashedRegenerate
                    (\hash opts' -> opts' { _cairoFileName = mkFile hash })
                    (_outDir opts)
                  )

  res <- DB.buildDiagram bopts

  case res of
    DB.ParseErr err    -> do
      hPutStrLn stderr ("\nError while parsing\n" ++ src)
      hPutStrLn stderr err
      return $ Left "Error while parsing"

    DB.InterpErr ierr  -> do
      hPutStrLn stderr ("\nError while interpreting\n" ++ src)
      hPutStrLn stderr (DB.ppInterpError ierr)
      return $ Left "Error while interpreting"

    DB.Skipped hash    -> do
      hPutStr stderr "."
      hFlush stderr
      return $ Right (mkFile (DB.hashToHexStr hash))

    DB.OK hash out -> do
      hPutStr stderr "O"
      hFlush stderr
      fst out
      return $ Right (mkFile (DB.hashToHexStr hash))

 where
  mkFile base = _outDir opts </> base <.> backendExt
  ensureDir dir = do
    b <- doesDirectoryExist dir
    when (not b) $ createDirectory dir
